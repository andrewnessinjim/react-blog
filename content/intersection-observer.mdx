---
title: "Understanding The Intersection Observer API"
abstract: One of the most commonly-misunderstood operators is Modulo (%). In this tutorial, we'll unpack exactly what this little bugger does, and learn how it can help us solve practical problems.
publishedOn: "2023-09-06T12:00:00-0400"
---

We can use [the browser's native IntersectionObserver API][1] to observe an element in the DOM and do something asynchronously when that element enters the viewport as the user is scrolling. In this blog post, I'll explain the concept behind this API and how the API can be used. I'll also show a real-world use case in React - infinite scrolling.

## Visualizing The Concept

To understand how the intersection observer works, imagine a web page as a box with a dashed outline. Within it, we have an element represented by a present üéÅ at the end.

<IndependentPage caption={<NoMarginParagraph>A webpage.</NoMarginParagraph>} />

Also, imagine the browser's viewport as a box with a solid outline. We need a scrollbar to visualize how this works, hence I've made the page longer than the viewport.

<IndependentViewport
  caption={<NoMarginParagraph>The viewport.</NoMarginParagraph>}
/>

Now, imagine placing the webpage within the viewport, visualized in the following interactive demo. If you drag the slider on the right, you can see the emoji change when the present enters the viewport.

<IntersectionObserverVisualizer
  caption={
    <NoMarginParagraph>
      Drag the slider on the right to scroll the page within the viewport.
    </NoMarginParagraph>
  }
/>

In technical terms, this state indicates an intersection where at least one pixel of the element being observed (called as the `target`) overlaps with the viewport. You can think of the change in emoji as the thing we want to do when an intersection occurs.

We can also say the target is _visible_ when at least one pixel of the target intersects with the viewport and its _invisible_ when there's no intersection. Let's look at some code!

## The API

Here's an implementation of the above behaviour in React. Play around by scrolling the page and see if you can figure out what's going on. I'll break down the parts right below the playground. Try scrolling the present in and out of view several times and compare it with the interactive demo above.

<SandpackDemo projectSubDir="interactionObserver/basic" />

We create an `InteractionObserver` by calling its contructor and passing in a callback:

```js
const observer = new IntersectionObserver(callback);
```

This `callback` will be invoked by the `observer` every time something interesting happens. Our callback simply logs "Interesting":

```js
() => {
  console.log("Interesting");
};
```

How does the observer know what is interesting to us? We have two knobs to control this. The first one is to specify the element we want to observe (we'll come back to the other knob shortly):

```js
observer.observe(observedElemRef.current); //This is the üéÅ
```

With this, the observer knows the element we're interested in. That covers all the parts in our minimal example. We can make the following observations from this example:

- "Interesting" is logged when the page first loads. (This actually happen when we first call the `observe` function on the `observer`. It just appears to happen on page load.)
- It's logged when the first pixel of the observed element üéÅ enters the viewport.
- It's also logged when the observed element exits the viewport.

This is the default behaviour of the IntersectionObserver when we do not use the second knob. Before looking at the second knob, let's see an example of what we can do with just the fist knob, i.e., just specifying the element we want to observe!

The Intersection Observer's callback is given the `entries` argument. The Observer collects all the interesting events and passes them along to our callback in the form of the `entries` array. In the previous example, we ignored the events. In this next example, we will look at the events and check if it says the observed element just entered the viewport and do something when it enters.

<SandpackDemo projectSubDir="interactionObserver/eyesOnEntry" />

Let's look at the `entries` argument:

```js
const observer = new IntersectionObserver((entries) => {
  const [entry] = entries;
  setIsPresentVisible(entry.isIntersecting);
});
```

We're plucking the one and only item from the `entries` argument. How do we know it has only one element? Because we have _observed_ only one element. When we observe multiple elements or tweak the second knob in certain ways, the Observer can pass along multiple events in a single callback invocation.

Each event in the array holds properties describing the event. For example, the `isIntersecting` property tells us if the observed element entered the viewport.

### The Second Knob: The Options Object
The second knob to control what we're interested in the second argument to the `IntersectionObserver' constructor. It's object with three optional properties.

```js
const options = {
  root: document.querySelector("#scrollArea"),
  rootMargin: "0px",
  threshold: 1.0,
};
```

We'll look at them in turn.

### `root`
Root is the element that acts as the viewport for checking the visibility of the target. In the above examples we never set the root explicitly; the default root is the browser viewport. In the context of the playground, the default root ended up being the iframe's viewport. The below sandbox shows an example with a custom root.

<SandpackDemo projectSubDir="interactionObserver/customRoot" />

### `rootMargin`
To customize the root element's edges to be used in intersection calculations. The above examples used the default margins, which is zeroes on all sides.

### `threshold`
to customize the percentage of the observed element's visibility that we're interested in. The above examples used the default threshold, which is `0`.

[1]: https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
